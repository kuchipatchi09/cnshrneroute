<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>최적 경로 그리기</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <style>
    :root {
      --bg:#ffffff; --card:#f8fafc; --ink:#0f172a; --muted:#475569; --accent:#2563eb;
      --border:#e5e7eb; --ink-weak:#334155; --chip:#eef2ff;
    }
    *{ box-sizing:border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,Arial; }
    header { padding:16px 20px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; background:#fff; position:sticky; top:0; z-index:10; }
    header h1 { margin:0; font-size:18px; font-weight:800; letter-spacing:.2px; }
    .container { display:grid; grid-template-columns:420px 1fr; height:calc(100vh - 58px); }
    .panel { background:var(--card); border-right:1px solid var(--border); overflow:auto; }
    .panel section { padding:16px; border-bottom:1px solid var(--border); }
    .panel h2 { font-size:13px; margin:0 0 8px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em; }
    label { font-size:12px; color:var(--muted); display:block; margin:8px 0 4px; }
    input[type="text"], textarea, select { width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#fff; color:var(--ink); }
    textarea { resize:vertical; min-height:140px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:flex; gap:8px; }
    .btn { display:inline-flex; align-items:center; gap:8px; background:#111827; color:#fff; border:1px solid #111827; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:700; }
    .btn.secondary{ background:#fff; color:#111827; border-color:var(--border); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .hint { font-size:12px; color:var(--muted); margin-top:6px; }
    .stats { font-size:13px; line-height:1.5; background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px; }
    .table { width:100%; border-collapse: collapse; font-size:12px; background:#fff; border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    .table th, .table td { padding:8px 10px; border-bottom:1px solid var(--border); text-align:left; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:var(--chip); color:#3730a3; font-size:11px; }
    #map { height:calc(100vh - 58px); width:100%; }
    .num-label { background:#ef4444; color:#fff; border-radius:8px; padding:2px 6px; font-size:11px; border:1px solid rgba(0,0,0,.12); }
    .footer { font-size:11px; color:var(--muted); }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>최적경로 그리기</h1>
    <div class="chip" id="statusPill">Idle</div>
  </header>
  <div class="container">
    <div class="panel">
      <section>
        <h2>Config</h2>
        <label>ORS API Key</label>
        <input id="apiKey" type="text" placeholder="YOUR_ORS_API_KEY" />
        <div class="row" style="margin-top:10px;">
          <div style="flex:1">
            <label>Profile</label>
            <select id="profile">
              <option value="driving-car" selected>driving-car</option>
              <option value="foot-walking">foot-walking</option>
              <option value="cycling-regular">cycling-regular</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Zoom</label>
            <input id="zoomStart" type="text" value="14" />
          </div>
        </div>
        <div class="hint">주소/좌표 입력 지원</div>
      </section>

      <section>
        <h2>Start</h2>
        <label>출발지 (주소 또는 "위도,경도")</label>
        <input id="startInput" type="text" placeholder="예: 36.813652,127.108917" />
        <div class="row" style="margin-top:8px;">
          <div style="flex:1">
            <label>시작 인덱스(백업)</label>
            <input id="startIndex" type="text" value="0" />
          </div>
          <div style="flex:1">
            <label>좌표 스냅 허용오차(m)</label>
            <input id="tolMeters" type="text" value="25" />
          </div>
        </div>
        <div class="hint">출발지가 목록의 점들과 ±오차 내에서 일치하면 해당 점에서 시작. 벗어나도 가장 가까운 점으로 자동 스냅됩니다.</div>
      </section>

      <section>
        <h2>Points (주소 또는 위도,경도)</h2>
        <label>아래에 각 지점을 한 줄에 하나씩 입력 (예: "부산역" 또는 "35.101934,129.030607")</label>
        <textarea id="pointsBox"></textarea>
        <label>라벨 (선택, 쉼표로 구분. 비우면 자동)</label>
        <input id="labelsBox" type="text" placeholder="A,B,C,D,..." />
        <div class="row" style="margin-top:10px; gap:12px;">
          <button class="btn" id="runBtn">최단 오픈 경로 그리기</button>
          <button class="btn secondary" id="clearBtn">초기화</button>
          <button class="btn secondary" id="testBtn" title="Parser self-test">테스트</button>
        </div>
      </section>

      <section>
        <h2>Results</h2>
        <div class="stats" id="stats"></div>
        <div style="margin-top:12px;">
          <table class="table" id="resultTable">
            <thead><tr><th>#</th><th>Label</th><th>Lat</th><th>Lon</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="footer" style="margin-top:8px;">오픈 경로(복귀 없음), 최근접이웃 → 2-opt. ORS Matrix/Directions + Leaflet.</div>
      </section>
    </div>
    <div id="map"></div>
  </div>

  <script>
    // ============ Helpers ============
    const $ = (sel) => document.querySelector(sel);
    const setStatus = (msg) => (document.querySelector("#statusPill").textContent = msg);

    function isLatLonLine(s){
      const m = s.split(/[ ,]+/).map(x=>x.trim());
      if(m.length < 2) return false;
      return !isNaN(parseFloat(m[0])) && !isNaN(parseFloat(m[1]));
    }

    function parseLatLon(s){
      const m=s.split(/[ ,]+/).map(x=>x.trim());
      return [parseFloat(m[0]), parseFloat(m[1])];
    }

    function ensureLonLat(latlon){ return latlon.map(([lat,lon])=>[lon,lat]); }

    function haversine(a,b){
      const R=6371000, toRad=d=>d*Math.PI/180; const [lat1,lon1]=a,[lat2,lon2]=b;
      const dlat=toRad(lat2-lat1), dlon=toRad(lon2-lon1);
      const s=Math.sin(dlat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dlon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }

    function nearestIndexWithDist(coordsLatLon, targetLatLon){
      const arr = coordsLatLon.map((p,i)=>[i, haversine(p,targetLatLon)]).sort((a,b)=>a[1]-b[1]);
      return arr[0]; // [idx, meters]
    }

    function normalizeLabels(lblStr, n){
      if(!lblStr) return Array.from({length:n}, (_,i)=>`Point ${i+1}`);
      const arr = lblStr.split(',').map(s=>s.trim()).filter(Boolean);
      return arr.length===n ? arr : Array.from({length:n}, (_,i)=>arr[i] ?? `Point ${i+1}`);
    }

    // ============ ORS REST ============
    async function orsGeocode(apiKey, text){
      const url = new URL('https://api.openrouteservice.org/geocode/search');
      url.searchParams.set('api_key', apiKey);
      url.searchParams.set('text', text);
      url.searchParams.set('size', '1');
      const r = await fetch(url, { headers: { 'Accept': 'application/json' }});
      if (!r.ok) throw new Error(`Geocode 실패: ${r.status}`);
      const j = await r.json();
      const feat = j.features?.[0];
      if (!feat) throw new Error(`지오코드 결과 없음: ${text}`);
      const [lon, lat] = feat.geometry.coordinates;
      return [lat, lon];
    }

    async function orsMatrix(apiKey, profile, coordsLonLat){
      const r = await fetch(`https://api.openrouteservice.org/v2/matrix/${profile}`,{
        method:'POST', headers:{'Authorization':apiKey,'Content-Type':'application/json'},
        body:JSON.stringify({ locations: coordsLonLat, metrics:['distance'], resolve_locations:true })
      });
      if(!r.ok) throw new Error(`Matrix 실패: ${r.status}`);
      const j = await r.json();
      return j.distances;
    }

    async function orsDirections(apiKey, profile, aLonLat, bLonLat){
      const r = await fetch(`https://api.openrouteservice.org/v2/directions/${profile}/geojson`,{
        method:'POST', headers:{'Authorization':apiKey,'Content-Type':'application/json'},
        body:JSON.stringify({ coordinates:[aLonLat,bLonLat] })
      });
      if(!r.ok) throw new Error(`Directions 실패: ${r.status}`);
      return await r.json();
    }

    // ============ Mixed input resolve (coords or addresses) ============
    async function resolvePointsFromTextarea(apiKey){
      // FIX: Split by real line breaks only (avoid invalid regex). Supports CRLF and LF.
      const lines = document.querySelector("#pointsBox").value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if(lines.length < 2) throw new Error('지점은 2개 이상 입력하세요.');
      const out = [];
      for(const line of lines){
        if(isLatLonLine(line)){
          out.push(parseLatLon(line));
        } else {
          const latlon = await orsGeocode(apiKey, line);
          out.push(latlon);
        }
      }
      return out; // [ [lat,lon], ... ]
    }

    // ============ Heuristics (Open path) ============
    function nearestNeighborOpen(M, start=0){
      const n=M.length, visited=Array(n).fill(false); const route=[start]; visited[start]=true; let cur=start;
      for(let step=0; step<n-1; step++){
        let best=-1, bestD=Infinity; for(let j=0;j<n;j++){ if(!visited[j] && j!==cur){ const d=M[cur][j]; if(d<bestD){bestD=d; best=j;} } }
        route.push(best); visited[best]=true; cur=best;
      } return route;
    }
    function twoOptOpen(route,M,fixStart=true){
      const n=route.length; const pathLen=r=>r.slice(0,-1).reduce((a,_,i)=>a+M[r[i]][r[i+1]],0);
      let best=route.slice(), bestLen=pathLen(best), improved=true, startI=fixStart?1:0;
      while(improved){ improved=false; for(let i=startI;i<n-2;i++){ for(let k=i+1;k<n-1;k++){ const nr=best.slice(0,i).concat(best.slice(i,k+1).reverse(),best.slice(k+1)); const nl=pathLen(nr); if(nl+1e-9<bestLen){best=nr; bestLen=nl; improved=true;} } } }
      return {route:best, meters:bestLen};
    }

    // ============ Map ============
    let map = L.map('map', { zoomControl: true }).setView([36.813652, 127.108917], 14);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom: 20, attribution: '&copy; OpenStreetMap' }).addTo(map);
    const drawnLayer = L.layerGroup().addTo(map);

    function clearMap(){ drawnLayer.clearLayers(); }

    function drawMarkers(coordsLatLon, labels, route){
      route.forEach((idx, order)=>{
        const [lat,lon]=coordsLatLon[idx];
        const m=L.marker([lat,lon]).addTo(drawnLayer);
        m.bindPopup(`${order+1}번째: ${labels[idx]}`).openPopup();
        const el=document.createElement('div'); el.className='num-label'; el.textContent=String(order+1);
        L.marker([lat,lon],{icon:L.divIcon({className:'', html:el, iconSize:[24,16]})}).addTo(drawnLayer);
      });
      const s=route[0], e=route[route.length-1];
      L.circleMarker(coordsLatLon[s], { radius:8, color:'#22c55e' }).addTo(drawnLayer).bindTooltip('출발지');
      L.circleMarker(coordsLatLon[e], { radius:8, color:'#ef4444' }).addTo(drawnLayer).bindTooltip('도착지');
    }

    async function drawDirections(apiKey, profile, coordsLonLat, route){
      for(let i=0;i<route.length-1;i++){
        const a=coordsLonLat[route[i]], b=coordsLonLat[route[i+1]];
        try{
          const gj=await orsDirections(apiKey, profile, a, b);
          const coords=gj.features[0].geometry.coordinates.map(([lon,lat])=>[lat,lon]);
          const line=L.polyline(coords, { weight:4 }).addTo(drawnLayer);
          L.polylineDecorator(line,{ patterns:[{ offset:7, repeat:40, symbol:L.Symbol.arrowHead({ pixelSize:10, pathOptions:{ weight:2 } }) }] }).addTo(drawnLayer);
        }catch(e){ console.warn(`[경고] 도로 경로 그리기 실패:`, e); }
      }
    }

    function fillTable(route, labels, coordsLatLon){
      const tbody = document.querySelector('#resultTable tbody');
      tbody.innerHTML='';
      route.forEach((idx,i)=>{
        const [lat,lon]=coordsLatLon[idx];
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td>${labels[idx]}</td><td>${lat.toFixed(6)}</td><td>${lon.toFixed(6)}</td>`;
        tbody.appendChild(tr);
      });
    }

    function showStats(km, n, secs){
      document.querySelector("#stats").innerHTML = `총 노드: <b>${n}</b><br/>총 경로 거리(도로): <b>${km.toFixed(2)} km</b><br/>소요시간: <b>${secs.toFixed(2)} s</b>`;
    }

    // ============ Dev: Parser Tests (no network) ============
    function runParserTests(){
      try{
        const sample = [
          '부산역',
          '35.101934,129.030607',
          '서울특별시청',
          '36.813652, 127.108917',
          '  ',
          '\t',
          '광안리 해수욕장'
        ].join('\n');
        const lines = sample.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        console.assert(lines.length===6, 'Line split should keep 6 non-empty lines');
        console.assert(isLatLonLine(lines[1])===true, 'Second line should be lat,lon');
        console.assert(isLatLonLine(lines[3])===true, 'Fourth line should be lat,lon (with space)');
        console.assert(isLatLonLine(lines[0])===false, 'First line is address');
        alert('Parser self-test passed.');
      }catch(e){
        alert('Parser test failed: '+(e.message||e));
      }
    }

    // ============ Main ============
    document.querySelector("#clearBtn").addEventListener('click', ()=>{ clearMap(); document.querySelector("#stats").textContent=''; document.querySelector("#resultTable tbody").innerHTML=''; setStatus('Cleared'); });
    document.querySelector("#testBtn").addEventListener('click', runParserTests);

    document.querySelector("#runBtn").addEventListener('click', async ()=>{
      try{
        setStatus('Resolving points...'); clearMap();
        const apiKey = document.querySelector("#apiKey").value.trim(); if(!apiKey) throw new Error('ORS API Key를 입력하세요.');
        const profile = document.querySelector("#profile").value; const zoom = parseInt(document.querySelector("#zoomStart").value)||14;

        // 1) Resolve points (address or lat,lon)
        const coordsLatLon = await resolvePointsFromTextarea(apiKey);
        const labels = normalizeLabels(document.querySelector("#labelsBox").value, coordsLatLon.length);

        // 2) Determine start index: snap-to-nearest if start provided
        let startIdx = parseInt(document.querySelector("#startIndex").value)||0; const startText = document.querySelector("#startInput").value.trim(); const tolM = parseFloat(document.querySelector("#tolMeters").value)||25;
        let startLatLon = null; let snapInfo = null;
        if(startText){
          if(isLatLonLine(startText)) startLatLon = parseLatLon(startText); else startLatLon = await orsGeocode(apiKey, startText);
          const [idx, distM] = nearestIndexWithDist(coordsLatLon, startLatLon);
          startIdx = idx; snapInfo = distM;
          if (distM > tolM) alert(`입력 출발지가 목록과 약 ${distM.toFixed(1)} m 떨어져 있어 가장 가까운 #${idx+1} 지점에서 시작합니다. (허용오차 ${tolM} m)`);
        }

        // 3) Map view
        map.setView(startLatLon ?? coordsLatLon[startIdx], zoom);
        setStatus(`Start @ #${startIdx+1}${snapInfo!=null?` (≈${snapInfo.toFixed(0)} m)`:''}`);

        // 4) Matrix + NN + 2-opt
        setStatus('Building distance matrix...');
        const coordsLonLat = ensureLonLat(coordsLatLon);
        const distM = await orsMatrix(apiKey, profile, coordsLonLat);
        setStatus('Nearest neighbor...');
        const rough = nearestNeighborOpen(distM, startIdx);
        setStatus('2-opt refining...');
        const t0 = performance.now();
        const { route, meters } = twoOptOpen(rough, distM, true);
        const t1 = performance.now();

        // 5) Draw
        setStatus('Drawing markers...');
        drawMarkers(coordsLatLon, labels, route);
        setStatus('Drawing directions...');
        await drawDirections(apiKey, profile, coordsLonLat, route);

        // 6) Stats/Table
        const km = meters / 1000.0;
        fillTable(route, labels, coordsLatLon);
        showStats(km, coordsLatLon.length, (t1 - t0)/1000);
        setStatus('Done');
      } catch(err){
        console.error(err); setStatus('Error'); alert(err.message || String(err));
      }
    });
  </script>
</body>
</html>
