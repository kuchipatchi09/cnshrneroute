<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>최적 경로 그리기</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <style>
    :root {
      --bg:#ffffff; --card:#f8fafc; --ink:#0f172a; --muted:#475569; --accent:#2563eb;
      --border:#e5e7eb; --ink-weak:#334155; --chip:#eef2ff;
    }
    *{ box-sizing:border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Ubuntu,Cantarell,Helvetica Neue,Arial; }
    header { padding:16px 20px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; background:#fff; position:sticky; top:0; z-index:10; }
    header h1 { margin:0; font-size:18px; font-weight:800; letter-spacing:.2px; }
    .container { display:grid; grid-template-columns:420px 1fr; height:calc(100vh - 58px); }
    .panel { background:var(--card); border-right:1px solid var(--border); overflow:auto; }
    .panel section { padding:16px; border-bottom:1px solid var(--border); }
    .panel h2 { font-size:13px; margin:0 0 8px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em; }
    label { font-size:12px; color:var(--muted); display:block; margin:8px 0 4px; }
    input[type="text"], textarea, select { width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#fff; color:var(--ink); }
    textarea { resize:vertical; min-height:140px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:flex; gap:8px; }
    .btn { display:inline-flex; align-items:center; gap:8px; background:#111827; color:#fff; border:1px solid #111827; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:700; }
    .btn.secondary{ background:#fff; color:#111827; border-color:var(--border); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .hint { font-size:12px; color:var(--muted); margin-top:6px; }
    .stats { font-size:13px; line-height:1.5; background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px; }
    .table { width:100%; border-collapse: collapse; font-size:12px; background:#fff; border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    .table th, .table td { padding:8px 10px; border-bottom:1px solid var(--border); text-align:left; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:var(--chip); color:#3730a3; font-size:11px; }
    #map { height:calc(100vh - 58px); width:100%; }
    .num-label { background:#ef4444; color:#fff; border-radius:8px; padding:2px 6px; font-size:11px; border:1px solid rgba(0,0,0,.12); }
    .footer { font-size:11px; color:var(--muted); }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>최적경로 그리기</h1>
    <div class="chip" id="statusPill">Idle</div>
  </header>
  <div class="container">
    <div class="panel">
      <section>
        <h2>Config</h2>
        <div class="row" style="margin-top:10px;">
          <div style="flex:1">
            <label>Profile</label>
            <select id="profile">
              <option value="driving-car" selected>driving-car</option>
              <option value="foot-walking">foot-walking</option>
              <option value="cycling-regular">cycling-regular</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Zoom</label>
            <input id="zoomStart" type="text" value="14" />
          </div>
        </div>
      </section>

      <section>
        <h2>Start</h2>
        <label>출발지 (주소 또는 "위도,경도")</label>
        <input id="startInput" type="text" placeholder="예: 36.813652,127.108917" />
        <div class="row" style="margin-top:8px;">
          <div style="flex:1">
            <label>시작 인덱스(백업)</label>
            <input id="startIndex" type="text" value="0" />
          </div>
          <div style="flex:1">
            <label>좌표 스냅 허용오차(m)</label>
            <input id="tolMeters" type="text" value="25" />
          </div>
        </div>
      </section>

      <section>
        <h2>Points</h2>
        <label>각 지점을 한 줄에 하나씩 입력 (예: "부산역" 또는 "35.101934,129.030607")</label>
        <textarea id="pointsBox"></textarea>
        <label>라벨 (쉼표로 구분, 비우면 자동)</label>
        <input id="labelsBox" type="text" placeholder="A,B,C,D,..." />
        <div class="row" style="margin-top:10px; gap:12px;">
          <button class="btn" id="runBtn">최단 오픈 경로 그리기</button>
          <button class="btn secondary" id="clearBtn">초기화</button>
        </div>
      </section>

      <section>
        <h2>Results</h2>
        <div class="stats" id="stats"></div>
        <div style="margin-top:12px;">
          <table class="table" id="resultTable">
            <thead><tr><th>#</th><th>Label</th><th>Lat</th><th>Lon</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="footer" style="margin-top:8px;">오픈 경로(복귀 없음), 최근접이웃 → 2-opt. ORS Matrix/Directions + Leaflet.</div>
      </section>
    </div>
    <div id="map"></div>
  </div>

  <script>
    const API_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjVlMmRiZDNmOWQwMjQyYTc5NTdiNzFlOWZiNzRiNjg2IiwiaCI6Im11cm11cjY0In0=";

    const $ = (sel) => document.querySelector(sel);
    const setStatus = (msg) => (document.querySelector("#statusPill").textContent = msg);

    function isLatLonLine(s){ const m = s.split(/[ ,]+/).map(x=>x.trim()); return m.length >= 2 && !isNaN(parseFloat(m[0])) && !isNaN(parseFloat(m[1])); }
    function parseLatLon(s){ const m=s.split(/[ ,]+/).map(x=>x.trim()); return [parseFloat(m[0]), parseFloat(m[1])]; }
    function ensureLonLat(latlon){ return latlon.map(([lat,lon])=>[lon,lat]); }

    async function orsGeocode(text){
      const url = new URL('https://api.openrouteservice.org/geocode/search');
      url.searchParams.set('api_key', API_KEY);
      url.searchParams.set('text', text);
      url.searchParams.set('size', '1');
      const r = await fetch(url);
      const j = await r.json();
      const feat = j.features?.[0];
      if(!feat) throw new Error(`지오코드 실패: ${text}`);
      const [lon,lat]=feat.geometry.coordinates;
      return [lat,lon];
    }

    async function orsMatrix(profile, coordsLonLat){
      const r = await fetch(`https://api.openrouteservice.org/v2/matrix/${profile}`, {
        method:'POST', headers:{'Authorization':API_KEY,'Content-Type':'application/json'},
        body:JSON.stringify({ locations: coordsLonLat, metrics:['distance'], resolve_locations:true })
      });
      const j = await r.json();
      return j.distances;
    }

    async function orsDirections(profile, aLonLat, bLonLat){
      const r = await fetch(`https://api.openrouteservice.org/v2/directions/${profile}/geojson`, {
        method:'POST', headers:{'Authorization':API_KEY,'Content-Type':'application/json'},
        body:JSON.stringify({ coordinates:[aLonLat,bLonLat] })
      });
      return await r.json();
    }

    function normalizeLabels(lblStr,n){ if(!lblStr) return Array.from({length:n},(_,i)=>`Point ${i+1}`); const arr=lblStr.split(',').map(s=>s.trim()).filter(Boolean); return arr.length===n?arr:Array.from({length:n},(_,i)=>arr[i]??`Point ${i+1}`); }

    async function resolvePointsFromTextarea(){
      const lines = $("#pointsBox").value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if(lines.length < 2) throw new Error('지점은 2개 이상 입력하세요. 첫번째 지점은 출발지의 좌표를 입력하세요.');
      const out = [];
      for(const line of lines){
        if(isLatLonLine(line)) out.push(parseLatLon(line));
        else out.push(await orsGeocode(line));
      }
      return out;
    }

    function nearestNeighborOpen(M,start=0){
      const n=M.length, visited=Array(n).fill(false); const route=[start]; visited[start]=true; let cur=start;
      for(let step=0;step<n-1;step++){
        let best=-1,bestD=Infinity;
        for(let j=0;j<n;j++){ if(!visited[j] && j!==cur){ const d=M[cur][j]; if(d<bestD){bestD=d;best=j;} } }
        route.push(best); visited[best]=true; cur=best;
      } return route;
    }

    function twoOptOpen(route,M,fixStart=true){
      const n=route.length; const pathLen=r=>r.slice(0,-1).reduce((a,_,i)=>a+M[r[i]][r[i+1]],0);
      let best=route.slice(), bestLen=pathLen(best), improved=true, startI=fixStart?1:0;
      while(improved){ improved=false; for(let i=startI;i<n-2;i++){ for(let k=i+1;k<n-1;k++){ const nr=best.slice(0,i).concat(best.slice(i,k+1).reverse(),best.slice(k+1)); const nl=pathLen(nr); if(nl+1e-9<bestLen){best=nr;bestLen=nl;improved=true;} } } }
      return {route:best, meters:bestLen};
    }

    let map=L.map('map').setView([36.813652,127.108917],14);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20}).addTo(map);
    const drawnLayer=L.layerGroup().addTo(map);
    function clearMap(){ drawnLayer.clearLayers(); }

    function drawMarkers(coordsLatLon,labels,route){
      route.forEach((idx,order)=>{
        const [lat,lon]=coordsLatLon[idx];
        const m=L.marker([lat,lon]).addTo(drawnLayer);
        m.bindPopup(`${order+1}번째: ${labels[idx]}`).openPopup();
        const el=document.createElement('div'); el.className='num-label'; el.textContent=String(order+1);
        L.marker([lat,lon],{icon:L.divIcon({className:'',html:el,iconSize:[24,16]})}).addTo(drawnLayer);
      });
    }

    async function drawDirections(profile,coordsLonLat,route){
      for(let i=0;i<route.length-1;i++){
        const a=coordsLonLat[route[i]], b=coordsLonLat[route[i+1]];
        try{
          const gj=await orsDirections(profile,a,b);
          const coords=gj.features[0].geometry.coordinates.map(([lon,lat])=>[lat,lon]);
          const line=L.polyline(coords,{weight:4}).addTo(drawnLayer);
          L.polylineDecorator(line,{patterns:[{offset:7,repeat:40,symbol:L.Symbol.arrowHead({pixelSize:10,pathOptions:{weight:2}})}]}).addTo(drawnLayer);
        }catch(e){ console.warn('경로 그리기 실패:',e); }
      }
    }

    function fillTable(route,labels,coordsLatLon){
      const tbody=$("#resultTable tbody"); tbody.innerHTML='';
      route.forEach((idx,i)=>{
        const [lat,lon]=coordsLatLon[idx];
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td>${labels[idx]}</td><td>${lat.toFixed(6)}</td><td>${lon.toFixed(6)}</td>`;
        tbody.appendChild(tr);
      });
    }

    function showStats(km,n){
      $("#stats").innerHTML = `총 노드: <b>${n}</b><br/>총 경로 거리(도로): <b>${km.toFixed(2)} km</b>`;
    }

    $("#clearBtn").addEventListener('click',()=>{clearMap();$("#stats").textContent='';$("#resultTable tbody").innerHTML='';setStatus('Cleared');});

    $("#runBtn").addEventListener('click', async ()=>{
      try{
        setStatus('Resolving points...'); clearMap();
        const profile=$("#profile").value; const zoom=parseInt($("#zoomStart").value)||14;
        const coordsLatLon=await resolvePointsFromTextarea();
        const labels=normalizeLabels($("#labelsBox").value,coordsLatLon.length);

        const startIdx=parseInt($("#startIndex").value)||0;
        map.setView(coordsLatLon[startIdx],zoom);

        setStatus('Building matrix...');
        const coordsLonLat=ensureLonLat(coordsLatLon);
        const distM=await orsMatrix(profile,coordsLonLat);

        setStatus('Calculating route...');
        const rough=nearestNeighborOpen(distM,startIdx);
        const {route,meters}=twoOptOpen(rough,distM,true);

        setStatus('Drawing...');
        drawMarkers(coordsLatLon,labels,route);
        await drawDirections(profile,coordsLonLat,route);

        const km=meters/1000.0;
        fillTable(route,labels,coordsLatLon);
        showStats(km,coordsLatLon.length);
        setStatus('Done');
      }catch(err){ console.error(err); setStatus('Error'); alert(err.message||String(err)); }
    });
  </script>
</body>
</html>
